ENGINE.OBJ={
  
  creteCustomWall: function (shape, extrudeSettings, color, x, y, z, rx, ry, rz, s) {
    //const extrudeSettings = { depth: 8, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
    //const loader = new THREE.TextureLoader();
    const texture = ENGINE.textureLoader.load("./textures/ground/x.png");
    // it's necessary to apply these settings in order to correctly display the texture on a shape geometry
    //texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    //texture.repeat.set(0.008, 0.008);
    // flat shape with texture
    // note: default UVs generated by THREE.ShapeGeometry are simply the x- and y-coordinates of the vertices
    let geometry = new THREE.ShapeGeometry(shape);
    // extruded shape
    geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    var mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({ color: color }));
    mesh.material.map = texture;
    mesh.position.set(x, y, z);
    mesh.rotation.set(rx, ry, rz);
    mesh.scale.set(s, s, s);
    ENGINE.scene.add(mesh);
    return mesh;
  }
  ,
  _createSingleWall: function (width, height) {
    const separator = 0.5;
    const pos = new THREE.Vector3();
    const quat = new THREE.Quaternion();
    const tam = new THREE.Vector3();
    pos.set(0, (height / 2) + separator, 0);
    quat.set(0, 0, 0, 1);
    tam.set(width, height, 1);
    var material = new THREE.MeshStandardMaterial({ color: 0xcccccc });
    //material.transparent=true;
    const texture = ENGINE.textureLoader.load("./textures/models/k.png");

    //"./textures/grid.png"
    var basebox = new THREE.BoxGeometry(tam.x, tam.y, tam.z, 1, 1, 1);
    var ammosize = new Ammo.btVector3(tam.x * 0.5, tam.y * 0.5, tam.z * 0.5);

    var tile = new THREE.Mesh(basebox, material);
    var shape = new Ammo.btBoxShape(ammosize);
    shape.setMargin(0.5);
    ENGINE.Physic.createRigidBody(tile, shape, 0, pos, quat);
    tile.castShadow = false;
    tile.receiveShadow = true;
    //texture.wrapS = THREE.RepeatWrapping;
    //texture.wrapT = THREE.RepeatWrapping;
    //texture.repeat.set(40, 40);
    tile.material.map = texture;
    tile.material.needsUpdate = true;
    return tile;

  },
}